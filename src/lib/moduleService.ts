// src/lib/moduleService.ts - OPTIMIZED VERSION

import { supabase } from './supabase';
import { SubPartField, SUBPARTS_CONFIG } from './types/programme';

// üî• NOUVEAU : Types pour l'optimisation
interface ModuleProgressData {
  subpart_id: number;
  entry_count: number;
  current_progress: number;
  is_completed: boolean;
}

interface BatchUpdateOperation {
  user_id: string;
  subpart_id: number;
  progress: number;
  completed: boolean;
  completed_at: string | null;
  updated_at: string;
}

export class ModuleService {
  
  // üî• NOUVEAU : Cache pour √©viter les recalculs inutiles
  private static progressCache = new Map<string, ModuleProgressData[]>();
  private static cacheTimestamp = new Map<string, number>();
  private static readonly CACHE_DURATION = 5000; // 5 secondes

  /**
   * üöÄ OPTIMIZED : Recalcul global ultra-rapide avec batch processing
   */
  static async recalculateAllModulesProgress(userId: string): Promise<void> {
    console.log(`üöÄ ModuleService - Recalcul global optimis√© pour user ${userId}`);
    const startTime = performance.now();
    
    try {
      // 1. üî• Single query pour r√©cup√©rer TOUTES les donn√©es n√©cessaires
      const moduleData = await this.fetchAllModuleDataInOneQuery(userId);
      
      // 2. üî• Calcul en m√©moire (ultra-rapide)
      const { progressUpdates, globalProgress } = this.calculateAllProgressInMemory(moduleData);
      
      // 3. üî• Batch update de tous les modules en une seule transaction
      await this.batchUpdateAllModules(userId, progressUpdates, globalProgress);
      
      // 4. üî• Mise √† jour du cache
      this.updateProgressCache(userId, moduleData);
      
      const endTime = performance.now();
      console.log(`‚úÖ Recalcul global termin√© en ${Math.round(endTime - startTime)}ms`);
      
    } catch (error) {
      console.error('üí• Erreur lors du recalcul global optimis√©:', error);
      throw error;
    }
  }

  /**
   * üöÄ OPTIMIZED : R√©cup√©ration de toutes les donn√©es en une seule requ√™te
   */
  private static async fetchAllModuleDataInOneQuery(userId: string): Promise<ModuleProgressData[]> {
    console.log('üìä R√©cup√©ration optimis√©e des donn√©es...');
    
    // Single query avec COUNT et JOIN pour tout r√©cup√©rer d'un coup
    const { data: entryCounts, error } = await supabase
      .from('programme_entries')
      .select('subpart_id')
      .eq('user_id', userId);

    if (error) {
      throw new Error(`Erreur r√©cup√©ration donn√©es: ${error.message}`);
    }

    // Compter les entr√©es par module en m√©moire (ultra-rapide)
    const entryCountMap = new Map<number, number>();
    entryCounts?.forEach(entry => {
      const count = entryCountMap.get(entry.subpart_id) || 0;
      entryCountMap.set(entry.subpart_id, count + 1);
    });

    // Construire les donn√©es pour tous les modules
    return SUBPARTS_CONFIG.map(config => {
      const entryCount = entryCountMap.get(config.id) || 0;
      const minRequired = config.minFields || 1;
      const progress = Math.min(100, Math.round((entryCount / minRequired) * 100));
      const isCompleted = progress >= 100;

      return {
        subpart_id: config.id,
        entry_count: entryCount,
        current_progress: progress,
        is_completed: isCompleted
      };
    });
  }

  /**
   * üöÄ OPTIMIZED : Calcul de toutes les progressions en m√©moire
   */
  private static calculateAllProgressInMemory(moduleData: ModuleProgressData[]): {
    progressUpdates: BatchUpdateOperation[];
    globalProgress: number;
  } {
    console.log('üßÆ Calcul des progressions en m√©moire...');
    
    const now = new Date().toISOString();
    const progressUpdates: BatchUpdateOperation[] = [];
    
    // üî• NOUVEAU : Logique de blocage en cascade COMPL√àTE
    let firstInvalidModuleIndex = -1;
    
    // Identifier le premier module invalide
    for (let i = 0; i < moduleData.length; i++) {
      const module = moduleData[i];
      if (!module.is_completed && firstInvalidModuleIndex === -1) {
        firstInvalidModuleIndex = i;
        break;
      }
    }

    // Construire les mises √† jour pour chaque module
    moduleData.forEach((module, index) => {
      let finalProgress = module.current_progress;
      let finalCompleted = module.is_completed;
      let finalCompletedAt: string | null = module.is_completed ? now : null;

      // üî• CORRECTION : Bloquer TOUS les modules apr√®s le premier invalide
      if (firstInvalidModuleIndex !== -1 && index > firstInvalidModuleIndex) {
        finalProgress = 0;
        finalCompleted = false;
        finalCompletedAt = null;
        console.log(`üîí Module ${module.subpart_id} bloqu√© (apr√®s module invalide ${firstInvalidModuleIndex + 1})`);
      }

      progressUpdates.push({
        user_id: '', // Sera rempli dans batchUpdate
        subpart_id: module.subpart_id,
        progress: finalProgress,
        completed: finalCompleted,
        completed_at: finalCompletedAt,
        updated_at: now
      });
    });

    // Calcul de la progression globale
    const totalProgress = progressUpdates.reduce((sum, update) => sum + update.progress, 0);
    const globalProgress = Math.round(totalProgress / progressUpdates.length);

    console.log(`üßÆ Progressions calcul√©es: global ${globalProgress}%, ${progressUpdates.filter(u => u.completed).length} modules compl√©t√©s`);
    
    return { progressUpdates, globalProgress };
  }

  /**
   * üöÄ OPTIMIZED : Mise √† jour en batch ultra-rapide
   */
  private static async batchUpdateAllModules(
    userId: string, 
    progressUpdates: BatchUpdateOperation[], 
    globalProgress: number
  ): Promise<void> {
    console.log('‚ö° Mise √† jour batch de tous les modules...');
    
    try {
      // Pr√©parer les donn√©es pour l'upsert batch
      const upsertData = progressUpdates.map(update => ({
        ...update,
        user_id: userId
      }));

      // üî• Single batch upsert pour tous les modules
      const { error: batchError } = await supabase
        .from('subpart_progress')
        .upsert(upsertData, {
          onConflict: 'user_id,subpart_id'
        });

      if (batchError) {
        throw new Error(`Erreur batch update modules: ${batchError.message}`);
      }

      // üî• Mise √† jour du programme global en parall√®le
      const { error: globalError } = await supabase
        .from('user_programmes')
        .upsert({
          user_id: userId,
          overall_progress: globalProgress,
          completed_at: globalProgress >= 100 ? new Date().toISOString() : null,
          last_updated: new Date().toISOString()
        }, {
          onConflict: 'user_id'
        });

      if (globalError) {
        throw new Error(`Erreur update global: ${globalError.message}`);
      }

      console.log(`‚ö° Batch update termin√©: ${progressUpdates.length} modules + global`);
      
    } catch (error) {
      console.error('üí• Erreur batch update:', error);
      throw error;
    }
  }

  /**
   * üî• NOUVEAU : Gestion du cache intelligent
   */
  private static updateProgressCache(userId: string, data: ModuleProgressData[]): void {
    this.progressCache.set(userId, data);
    this.cacheTimestamp.set(userId, Date.now());
  }

  private static getCachedProgress(userId: string): ModuleProgressData[] | null {
    const timestamp = this.cacheTimestamp.get(userId);
    if (!timestamp || Date.now() - timestamp > this.CACHE_DURATION) {
      return null;
    }
    return this.progressCache.get(userId) || null;
  }

  /**
   * üöÄ OPTIMIZED : Mise √† jour d'une entr√©e avec cache
   */
  static async updateField(userId: string, fieldId: string, newValue: string): Promise<void> {
    console.log(`‚úèÔ∏è ModuleService - Mise √† jour entr√©e optimis√©e ${fieldId}`);
    
    const { error } = await supabase
      .from('programme_entries')
      .update({ 
        value: newValue.trim(),
        updated_at: new Date().toISOString()
      })
      .eq('id', fieldId)
      .eq('user_id', userId);

    if (error) {
      throw new Error(`Erreur mise √† jour: ${error.message}`);
    }

    // Invalider le cache et recalculer
    this.invalidateCache(userId);
    await this.recalculateAllModulesProgress(userId);
  }

  /**
   * üöÄ OPTIMIZED : Suppression d'une entr√©e avec recalcul optimis√©
   */
  static async deleteField(userId: string, fieldId: string, subPartId: number): Promise<void> {
    console.log(`üóëÔ∏è ModuleService - Suppression entr√©e optimis√©e ${fieldId}`);
    
    const { error } = await supabase
      .from('programme_entries')
      .delete()
      .eq('id', fieldId)
      .eq('user_id', userId);

    if (error) {
      throw new Error(`Erreur suppression: ${error.message}`);
    }

    // Invalider le cache et recalculer
    this.invalidateCache(userId);
    await this.recalculateAllModulesProgress(userId);
  }

  /**
   * üöÄ OPTIMIZED : V√©rification d'acc√®s avec cache
   */
  static async canAccessModule(userId: string, subPartId: number): Promise<boolean> {
    console.log(`üîê ModuleService - V√©rification acc√®s optimis√©e module ${subPartId}`);
    
    if (subPartId === 1) return true;

    try {
      // Essayer le cache d'abord
      const cachedData = this.getCachedProgress(userId);
      if (cachedData) {
        const prevModule = cachedData.find(m => m.subpart_id === subPartId - 1);
        if (prevModule) {
          console.log(`üéØ Cache hit pour module ${subPartId - 1}`);
          return prevModule.is_completed;
        }
      }

      // Fallback vers DB si pas de cache
      const { data: prevProgress, error } = await supabase
        .from('subpart_progress')
        .select('completed')
        .eq('user_id', userId)
        .eq('subpart_id', subPartId - 1)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          await this.recalculateAllModulesProgress(userId);
          return false;
        }
        return false;
      }

      return prevProgress?.completed || false;
      
    } catch (error) {
      console.error('üí• Erreur v√©rification acc√®s:', error);
      return subPartId === 1;
    }
  }

  /**
   * üî• NOUVEAU : Invalidation du cache
   */
  private static invalidateCache(userId: string): void {
    this.progressCache.delete(userId);
    this.cacheTimestamp.delete(userId);
    console.log(`üóëÔ∏è Cache invalid√© pour user ${userId}`);
  }

  /**
   * üî• NOUVEAU : M√©thode utilitaire pour obtenir la progression actuelle
   */
  static async getCurrentProgress(userId: string): Promise<ModuleProgressData[]> {
    const cachedData = this.getCachedProgress(userId);
    if (cachedData) {
      console.log('üéØ Utilisation du cache pour getCurrentProgress');
      return cachedData;
    }

    return await this.fetchAllModuleDataInOneQuery(userId);
  }

  /**
   * üî• NOUVEAU : Nettoyage du cache (√† appeler p√©riodiquement)
   */
  static cleanupCache(): void {
    const now = Date.now();
    const expiredUsers: string[] = [];

    this.cacheTimestamp.forEach((timestamp, userId) => {
      if (now - timestamp > this.CACHE_DURATION) {
        expiredUsers.push(userId);
      }
    });

    expiredUsers.forEach(userId => {
      this.progressCache.delete(userId);
      this.cacheTimestamp.delete(userId);
    });

    if (expiredUsers.length > 0) {
      console.log(`üßπ Cache nettoy√©: ${expiredUsers.length} utilisateurs expir√©s`);
    }
  }

  // M√©thodes utilitaires conserv√©es
  static getPreviousModule(currentSubPartId: number) {
    const currentIndex = SUBPARTS_CONFIG.findIndex(c => c.id === currentSubPartId);
    return currentIndex > 0 ? SUBPARTS_CONFIG[currentIndex - 1] : null;
  }

  static getNextModule(currentSubPartId: number) {
    const currentIndex = SUBPARTS_CONFIG.findIndex(c => c.id === currentSubPartId);
    return currentIndex < SUBPARTS_CONFIG.length - 1 ? SUBPARTS_CONFIG[currentIndex + 1] : null;
  }
}